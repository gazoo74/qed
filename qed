#!/bin/sh

# This file is part of the qed project (https://github.com/vivien/qed).
#
# Copyright (c) 2016-2017 Vivien Didelot
# Copyright (c) 2016-2017 Lionel Nicolas
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# exit on failure
set -e

# exit on unassigned variable
set -u

# define colors
RESTORE='\033[0m'
RED='\033[01;31m'
GREEN='\033[01;32m'
YELLOW='\033[01;33m'
BLUE='\033[01;34m'

# define logging fumctions
logme() {
	echo "${GREEN}qed: $*${RESTORE}"
}

fatal() {
	echo "\n${RED}qed: $*${RESTORE}\n" >&2
	exit 1
}

# define usage
usage() {
	echo "usage: $0 [-h] [-d DISTRIBUTION] [-i] [-l] [-r] [-b] [-p] [CMD ARGS]"
	echo
	echo "	-h	show this help message"
	echo "	-d	target distribution image (a custom one can be used, like 'my.registry/builder/ubuntu:10.04')"
	echo "	-i	enter interactive mode"
	echo "	-b	force re-build of a local docker base image"
	echo "	-p	force pull of docker base image from registry"
	echo "	-f	force re-creation of the docker container"
	echo "	-r	remove all containers associated to current working directory"
}

list() {
	echo "listing containers"
	# TODO
}

remove() {
	echo "removing containers"
	# TODO
}

# prepare docker image
docker_prepare() {
	# force pull if docker image is not found (and 'build' is not requested)
	if ! ${pull} && ! ${rebuild}; then
		if [ -z "`docker images -q ${hash}-${project}-${distribution}`" ]; then
			pull=true
		fi
	fi

	# (re)build docker image
	if ${rebuild}; then
		if [ -f ".qed/dockerfile.${distribution}" ]; then
			docker build \
				--tag ${hash}-${project}-${distribution_sanitized} \
				--file .qed/dockerfile.${distribution} \
				${docker_build_args:-} \
				.qed/

		else
			fatal "no dockerfile corresponding to ${distribution} found in .qed/ directory"
		fi

	# only pull distribution image to use it directly (without any changes)
	elif ${pull}; then
		docker pull ${distribution}
		docker tag ${distribution} ${hash}-${project}-${distribution_sanitized}
	fi
}

# run (or start) docker container
docker_run() {
	# flush and recreate docker container (if any)
	docker rm -f ${hash}-${project}-${distribution_sanitized} 2>/dev/null || true

	logme "starting new container based on ${distribution} (docker image is ${hash}-${project}-${distribution_sanitized})"
	docker run \
		--detach \
		--name ${hash}-${project}-${distribution_sanitized} \
		--hostname ${hash}-${project}-${distribution_sanitized} \
		--volume ${PWD}:${PWD} \
		--workdir ${PWD} \
		--user ${uid}:${gid} \
		${hash}-${project}-${distribution_sanitized} \
		sleep INFINITY

	# create uid and gid in the container if their are not present
	# this will also make them fit with the current user/group names
	if ! docker exec ${hash}-${project}-${distribution_sanitized} id -g ${gid} >/dev/null 2>&1; then
		docker exec --user root ${hash}-${project}-${distribution_sanitized} groupadd --gid ${gid} `id -gn`
	fi

	if ! docker exec ${hash}-${project}-${distribution_sanitized} id -u ${uid} >/dev/null 2>&1; then
		docker exec --user root ${hash}-${project}-${distribution_sanitized} useradd --uid ${uid} --gid ${gid} `id -un`
	fi
}

# execute command inside docker container
docker_exec() {
	if [ -z "$*" ]; then
		fatal "no command to execute supplied"
	fi

	if ${flush}; then
		# flush is required, so recreate the container
		docker_run

	elif [ -z "`docker ps -aq --filter=name=${hash}-${project}-${distribution_sanitized}`" ]; then
		# no container exists, so create one
		docker_run

	else
		# container already exists, so make sure that it's running
		docker start ${hash}-${project}-${distribution_sanitized} >/dev/null
	fi

	logme "running command '$@' on ${distribution}"

	exec docker exec \
		${interactive} \
		${hash}-${project}-${distribution_sanitized} \
		$@
}

# default values (some of them can be set in configuration files)
distribution=
curdir=${PWD}
project=$(basename ${PWD})
hash=$(pwd | sha1sum | cut -c 1-8)
uid=`id -u`
gid=`id -g`
interactive=
rebuild=false
pull=false
list=false
remove=false
action=run
flush=false

# source global config file if found
if [ -f ${HOME}/.qed/config ]; then
	. ${HOME}/.qed/config
fi

# source local config file if found
if [ -f .qed/config ]; then
	. .qed/config
fi

# parse parameters
while getopts "hd:ilrbpf" opt; do
	case $opt in
		h) usage; exit 0 ;;
		d) distribution="${OPTARG}" ;;
		i) interactive="--interactive --tty" ;;
		b) rebuild=true ;;
		p) pull=true ;;
		f) flush=true ;;
		l) action=list ;;
		r) action=remove ;;
		*) usage; exit 1 ;;
	esac
done

# skip all qed parameters
shift "$((OPTIND-1))"

# check distribution parameter
if [ -z "${distribution}" ]; then
	fatal "distribution is not set"
fi

# sanitize distribution name
distribution_sanitized=`echo ${distribution} | sed 's/:/-/g' | rev | cut -d/ -f1 | rev`

# check action
case ${action} in
	list|remove)
		${action}
		;;

	run)
		docker_prepare
		docker_exec $@
		;;

	*)
		fatal "unsupported action ${action}" ;;
esac
